# C primer Plus之字符串和格式化输入输出

## 1. 前导程序

```c
#include <stdio.h>
// 引入String字符串的头文件
// 提供strlen()函数的原型
#include <string.h>
// #define指令 也叫做预处理器指令
// 当前预处理指令提前定义常量DENSITY定义为62.4, 方便代码中直接引入
#define DENSITY 62.4

int main(void) {

    char name[40];
    int age, size, letters;
    printf("%f", DENSITY);


    // 处理姓名
    printf("你叫什么名字? \n");
    scanf("%s", name);
    // 处理年龄
    printf("你有多少岁? \n");
    scanf("%d", &age);

    // 获取数组的大小
    size = sizeof(name);
    // 获取数组中存储字符的实际长度, 也就是字符串的长度
    letters = strlen(name);

    printf("你的姓名由%d个字符组成, %s \n", letters, name);
    printf("当前有多少%d个字节存储它", size);

    return 0;
}
```

- 输出结果

```
62.400000 
你叫什么名字? 
Tony
你有多少岁? 
18
你的姓名由4个字符组成, Tony 
当前有多少40个字节存储它
```

### 1.1 程序解读

- 引入String字符串头文件，提供操作字符串的相关函数

```c
#include <string.h>
```

- 预处理指令

```c
#define DENSITY 62.4
```

通过 `#define`关键字定义预处理指定，预处理指令表示在程序之前的准备工作。

`#define DENSITY 62.4`表示在程序运行之前，提前定义好 `DENSITY`常量，并将其赋值。值得注意的是，通过预处理指令定义的常量是不能修改的，只能在程序中引用。`printf("%f", DENSITY);`就是程序中对预处理指令中定义的常量的引用。

- 数组的声明

```c
char name[40];
```

声明一个可以存储40个字符的字符型数组，当前使用字符数组存储字符串。

数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符。

- 字符串使用scanf函数赋值，与字符串的格式化输出

```c
scanf("%s", name);
printf("你的姓名由%d个字符组成, %s \n", letters, name);
```

字符串使用 `%s` 来赋值和打印。值得注意的是，使用scanf为字符串赋值时，与对基本数据类型的变量赋值不同的是没有借助 `&`符号，比如 `scanf("%d", &age);`语句中，对age进行赋值时，就用到了 `&`。

> 注意：
>
> scanf函数读取字符串时，他在遇到第1个空白（空格、制表符或者换行符）时就不再读取输入。

- 获取数组的大小

```c
 size = sizeof(name);
```

借助内置运算符sizeof，可以获取到数组占用的字节大小，因为char型字符只会占用一个字节，所以40个char型字符就会占用40个字节。

- 获取字符串的长度

```c
 letters = strlen(name);
```

借助strlen函数获取到字符串的长度。

## 2. 数组

> 数组是同类型数据元素的有序序列。

### 2.1 数组的特点

- 内存中的连续性。数组由连续的存储单员组成。
- 存储的是同类型元素。

> 注意：
>
> 如果数组的大小大于实际存储的数据的大小， 多余的部分一般而言会存储垃圾垃圾数据。（经测试，整型数组多余的部分存储的是0；而字符型数组存储的随机垃圾字符，每次输出的值都不一样）。

代码示例

```c
#include <stdio.h>

/**
 * 数组
 * @return
 */
int main(void) {

    // 声明一个整数类型的数组
    // 只能存储的整数类型的数
    // 在内存中是连续的创建了10个整数存取空间
    // 当前操作系统,一个int类型占用4个字节,5个占用20个字节
    // 所以数组a直接在内存中创建了20个字节内存大小
    int a[] = {1,2,3,4,5};

    printf("%zd", sizeof a);

    return 0;
};
```

输出结果

```
20
```

## 3. 字符串

### 3.1 字符串的特点

- 字符串是一个或多个字符的序列。
- 字符串用双引号包裹。
- C语言中没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。
- C语言中的字符串一定以`空字符`结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。

> 注：空字符用转义字符表示就是 `\0`。空字符是非打印字符，因为在char型数据中\0会被解析成八进制的标志。空字符在ASCII码值是0。

### 3.2 比较'A'和"A"

- 'A'是字符常量，而"A"是字符串常量。
- 'A'是char基本类型，而"A"是char数组派生类型。
- "A"实际上由两个字符组成（'A'和'\0'）。

### 3.3 字符串断行

字符串断行表示当字符串比较长想要多行编写时，如何处理？

- 使用字符串连接。在两个双引号括起来的字符串之间用0到多个空白符隔开，C编译器会把多个字符串看作是一个字符串。

代码演示

```c
#include <stdio.h>
/**
 * 字符串的断行
 * @return
 */
int main(void) {
    printf("123""456\n");
    char c[40] = "123"    "456";
    printf("%s", c);
    return 0;
};
```

输出结果

```
123456
123456
```

## 4. 常量和C预处理器

什么是常量？常量就是在初始化之后`不能被修改`的数据。

### 4.1 定义常量的几种方式

- 数据未被赋值给提前定义好的数据类型而直接参与运算的数据。
- 通过C预处理器定义的常量
- 通过关键字const声明的常量

几种方式的代码演示

```c
// 通过预处理器定义常量
#define PI 3.141592654

/**
 * 定义常量
 * @return
 */
int main(void) {

    int a = 1;
    // 这里的2就是未被声明直接使用,2就是常量,不会被重复利用
    int b = a + 2;
    // 这里调用预处理器定义的常量
    double c = a * b * PI;
    // 这里使用const关键字定义常量
    const int D = 5;

    return 0;
};
```

> 注：
>
> 1、一般通过预处理器和const声明的常量因为具有常量名所以也叫符号常量。
>
> 2、符号常量相对于通过直接使用声明的常量的优势：
>
> - 具有常量名的话可以重复使用。
> - 当需要修改常量的值时，我们直接修改一处即可，其他引用常量名的地方自动会修改。
> - 常量名看起来比数字表达的信息更多，通过常量名可以帮助我们传达出该常量的实际意义。
>
> 3、符号常量一般情况下，常量名采用大写声明，方便区分常量和变量。有时也会用c\_或者k\_前缀来表达。

### 4.2 预处理器

预处理器的作用在于为程序声明各种数据类型的常量。

- 预处理器声明常量的格式

```c
#defined 常量名 常量值
```

- 预处理器工作原理

在程序中通过使用预处理器的常量名称使用到常量值，C语言在编译期间会将程序中所有的常量名替换成指定的常量值，这一过程也叫 `编译时替换`。

### 4.3 const限定符

通过const限定符声明的变量会被限定为只读，那么换句话说，通过const声明的数据就是常量。

- const限定符声明常量的的格式

```c
const 数据类型 常量名 = 常量值;
```

### 4.4 明示常量

什么是明示常量？明示常量指的是C语言中通过头文件内置的一些预处理器声明的常量，通过引入这些头文件，就可以在程序中直接使用这些常量。

常用的内含明示常量的头文件有 `limits.h`、`float.h`等。我们可以直接打开对应的头文件进行查看。

- limits.h

limits.h头文件中主要提供了与整数类型大小限制相关的详细信息。

下面列表部分明示常量

| 明示常量   | 含义                           |
| ---------- | ------------------------------ |
| CHAR_BIT   | char类型的位数                 |
| CHAR_MAX   | char类型的最大值               |
| CHAR_MIN   | char类型的最小值               |
| SCHAR_MAX  | signed char类型的最大值        |
| SCHAR_MIN  | signed char类型的最小值        |
| UCHAR_MAX  | unsigned char类型的最大值      |
| SHRT_MAX   | short类型的最大值              |
| INT_MAX    | int类型的最大值                |
| UINT_MAX   | unsigned int 类型的最大值      |
| LONG_MAX   | long 类型的最大值              |
| ULONG_MAX  | unsigned long类型的最大值      |
| LLONG_MAX  | long long类型的最大值          |
| ULLONG_MAX | unsigned long long类型的最大值 |

代码示例

```c
#include <stdio.h>
// 定义了关于整数类型大小限制的明示常量
#include <limits.h>

/**
 * 测试limits.h头文件
 * @return
 */
int main(void) {

    // 获取到char类型的位数
    int a = CHAR_BIT;
    printf("char类型的位数 = %d \n", a);

    int b = INT_MAX;
    printf("int类型的最大值 = %d \n", b);

    int c = INT_MIN;
    printf("int类型的最小值 = %d \n", c);

    return 0;
};
```

输出结果

```
char类型的位数 = 8 
int类型的最大值 = 2147483647 
int类型的最小值 = -2147483648 
```

- float.h

float.h头文件中主要提供了浮点类型大小限制的相关信息。

下面列举部分明示常量

| 明示常量       | 含义                                              |
| -------------- | ------------------------------------------------- |
| FLT_MANT_DIG   | float类型的尾数位数                               |
| FLT_DIG        | float类型的最少有效数字位数（十进制）             |
| FLT_MIN_10_EXP | 带全部有效数字的float类型的最小负指数（以10为底） |
| FLT_MAX_10_EXP | 带全部有效数字的float类型的最大正指数（以10为底） |
| FLT_MIN        | 保留全部精度的float类型最小正数                   |
| FLT_MAX        | 保留全部精度float类型的最大正数                   |

代码示例

```c
#include <stdio.h>
#include <float.h>

/**
 * 测试float.h头文件
 * @return
 */
int main(void) {

    printf("float类型的尾数位数 = %d \n", FLT_MANT_DIG);
    printf("float类型的最少有效数字位数 = %d \n", FLT_DIG);
    printf("float类型的最小负指数 = %d \n", FLT_MIN_10_EXP);
    printf("float类型的最大正整数 = %d \n", FLT_MAX_10_EXP);
    printf("float类型的最小正数 = %f \n", FLT_MIN);
    printf("float类型的最大正数 = %f \n", FLT_MAX);
    printf("1.00和比1.00大的最小float类型之间的差值 = %f \n", FLT_EPSILON);


    return 0;
};
```

输出结果

```
float类型的尾数位数 = 24 
float类型的最少有效数字位数 = 6 
float类型的最小负指数 = -37 
float类型的最大正整数 = 38 
float类型的最小正数 = 0.000000 
float类型的最大正数 = 340282346638528859811704183484516925440.000000 
1.00和比1.00大的最小float类型之间的差值 = 0.000000 
```

## 5. 格式化输入和输出

C语言中的格式化输入和输出是通过输入、输出函数实现的，输入输出函数也叫做I/O函数。

C语言中最典型的输入输出函数就是scanf函数和printf函数。

### 5.1 printf函数

printf是C语言中的格式化输出函数。

- #### 转换说明

printf函数有一个典型的特点，它要求打印的数据的指令要与待打印数据的类型相匹配。比如，打印整数时使用%d，打印字符时使用%c。这些符号被称为`转换说明`。

转换说明的作用是什么？它们指定了如何把数据转换成可显示的形式。

转换说明的意义是什么？转换说明把以二进制格式存储在计算机中的值转化成一系列字符或者字符串以便以显示。

常见的转换说明：

| 转换说明 | 输出                                                         |
| -------- | ------------------------------------------------------------ |
| %a、%A   | 浮点数、十六进制数和p记数法                                  |
| %e、%E   | 浮点数、e记数法                                              |
| %f       | 浮点数、十进制记数法                                         |
| %g、%G   | 根据值不同，自动选择%f或%e。%e格式用于指数小于-4或者大于或等于精度时。 |
| %c       | 单个字符                                                     |
| %d、%i   | 有符号十进制整数                                             |
| %u       | 无符号十进制整数                                             |
| %o       | 无符号八进制整数                                             |
| %x、%X   | 无符号十六进制整数                                           |
| %p       | 指针                                                         |
| %s       | 字符串                                                       |
| %%       | 打印一个百分号                                               |

- #### 函数的格式

```c
printf(格式字符串，待打印项，待打印项...)
```

待打印项都是要打印的项。他们可以是常量、变量、甚至是先要计算的表达式。

格式字符串应包含每个待打印项对应的转换说明。如果转换说明的个数大于待打印项，系统会取随机的数填充。

- #### 转换说明修饰符

在%和转换字符之间插入修饰符可修饰基本的转换说明。

常用的修饰符如下

| 修饰符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| -      | 待打印项左对齐。即从字段的左侧开始打印该项。该符号常与数字修饰符连用，数字修饰符表示最小字段宽度，当达不到就会空格代替，当与-连用时，就会先输出数据再打印空格。如"%-20s"、"%-20d"。 |
| +      | 有符号值若为正，则在值前面显示加号；若为负，则在值前面显示减号。如"%+6.2f"。 |
| 空格   | 有符号值若为正，则在值前面显示前导空格（不显示任何符号）；若为负，则在值前面显示减号。（注：+标记会覆盖空格标记）。如"% 6.2f"。 |
| #      | 把结果转换成另一种形式。如果是%o格式，则以0开始；如果是%x或%X格式，则以0x或0X开始；对于所有的浮点格式，#保证了即使后面没有任何数字，也打印一个小数点字符；对于%g和%G格式，#防止后面的0被删除。如"%#o"、"%#a"、"%+#10.3e"。 |
| 0      | 对于数值格式，用前导0代替空格填充字段宽度。(注：对于整数格式，如果出现-标记或指定精度，则忽略该标记；该标记常与数字修饰结合使用，如果待打印的值得宽度达不到指定的宽度则用0补充)。如"%04d"。 |
| 数字   | **最小字段宽度**。如果待打印值达不到指定的宽度，则用空格代替。如"%4d"。 |
| .数字  | 精度。对于%e、%E、%f转换，表示小数点右边数字的位数；对于%g、%G转换，表示有效数字的最大位数；**对于%s，表示带打印数字的最大位数；**对于整型转换，表示待打印数字的最小位数，如有必要，使用前导0来达到这个位数。只使用 `.`表示其后面跟随一个0，所以%.f和%.0f相同，其表示为不展示小数部分以及小数点，只显示整数部分。示例"%5.2f"打印一个浮点数，字段宽度为5字符，其中小数点后有两位数字。 |
| h      | 和整型转换说明一起使用，表示short int 或者 unsigned short int 类型的值。示例："%hu"、"%hx"、"%6.4hd"。 |
| hh     | 和整型转换说明一起使用，表示signed char 或者 unsigned char类型的值。示例："%hhu"、"%hhx"、"%6.4hhd"。 |
| j      | 和整型转换一起使用，表示 intmax_t 或 uintmax_t 类型的值。这些值定义在stdint.h中。示例："%jd"、"%8jx"。 |
| l      | 和整形转换说明一起使用，表示long int 或者 unsigned long int类型的值。示例："%ld"、"%8lu"。 |
| ll     | 和整形转换说明一起使用，表示long long int 或者 unsigned long long  int类型的值。示例："%lld"、"%8llu"。 |
| L      | 和浮点转换说明一起使用，表示 long double类型的值。示例："%Ld"、"%10.4Le"。这里要说的是普通的浮点类型float、double一般都是用%f转换说明来格式化输出的。 |
| t      | 和整形转换说明一起使用，表示ptrdiff_t类型的值。ptrdiff_t是两个指针差值的类型。示例："%td"、"%12ti"。 |
| z      | 和整形转换说明一起使用，表示size_t类型的值。size_t是sizeof的返回类型。示例："%zd"、"%12zd"。 |

代码演示

```c
#include <stdio.h>
#include <float.h>
#include "limits.h"
#include <stdint.h>

/**
 * 转换说明修饰符
 * @return
 */
int main(void) {

    char name[] = {'1', '2', '3'};
    // 默认情况下,字符串是右对齐方式,先输出空格后输出字符
    // - 转换说明修饰符 强制使用左对齐
    printf("%-20s \n %20s \n", name, name);
    printf("%+d, %+d \n", INT_MAX, INT_MIN);
    printf("% d, % d \n", INT_MAX, INT_MIN);
    // #符号保证了浮点类型的值打印时必有小数点
    printf("%#o, %#x, %a, %#a, %#g, %#g \n", 12, 12, 16., 16., 12., 12.);
    printf("%04d \n", LONG_BIT);
    printf("%4d \n", LONG_BIT);

    // .数字 表示精度
    printf("%.4e, %.4f, %.g, %.4g, %.f \n", FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX, FLT_MAX);
    printf("%.4s, %.4s \n", "ABCDEFG", "AB");
    // .数字对于整数表示待打印的最小位数,超过就不会填充0
    printf("%.4d, %04d, %.4d \n", CHAR_BIT, CHAR_BIT, INT_MAX);

    // 对于%6.4hd, %6要求最低位数为6位,空缺补空格;.4要求最低位数为4位,空缺补0,最后0会覆盖空格.
    printf("%hu, %hx, %6.4hd, %3.4hd \n", SHRT_MAX, SHRT_MAX, SHRT_MAX, CHAR_BIT);
    printf("%hhu, %hhx, %6.4hhd \n", (char) -128, (char)-128, (char)-128);

    intmax_t a = 123;
    uintmax_t b = 456;
    printf("%jd, %jx \n", a, b);

    printf("%zd", sizeof(char));
    return 0;
};
```

输出结果

```
123                  
                  123 
+2147483647, -2147483648 
 2147483647, -2147483648 
014, 0xc, 0x1p+4, 0x1.p+4, 12.0000, 12.0000 
0064 
  64 
3.4028e+38, 340282346638528859811704183484516925440.0000, 3e+38, 3.403e+38, 340282346638528859811704183484516925440 
ABCD, AB 
0008, 0008, 2147483647 
32767, 7fff,  32767, 0008 
128, 80,  -0128 
123, 1c8 
1
```

> 注意：
>
> 1、sizeof运算符以字节为单位返回类型或值的大小，C语言标准中只规定了该值是无符号的整数。在不同的实现中，他可以是unsigned int、unsigned long甚至是unsigned long long，所以要想程序在使用sizeof运算符具有类型可移植性，那么最好使用 `%zd`转换说明来格式化输出sizeof的返回值。因为在stddef.h（在包含stdio.h头文件时已包含其中）头文件中把size_t定义成系统使用sizeof返回的类型，这被称为`底层类型`。 
>
> 2、printf函数中所有的float类型的参数会自动转换成double类型，所以没有显示float类型值专用的转换说明，都是直接使用double的。

- #### 转换不匹配

对于转换说明应该与待打印值的类型相匹配。但是当转换说明与待打印的值的类型不匹配会怎么样？

上面提到过，转换说明的意义在于把以二进制形式存储在计算机中的值转化成一系列字符或者字符串。也就是说忽略值原始的类型，直接按照转换说明将值转换成对应的形式输出。

因为每种数据类型都有对应的内存空间，一般来说char占1个字节、short占2个字节、int和long占用4个字节、long long 占用8个字、float占4个字节、double占8个字节，而对应的unsigned只是将最前面一位的符号位转换成可参与计算的值，增大数据类型的取值范围。

总而言之，转换不匹配的问题会变成数据的截取、数据符号位的转换等，只要知道最后输出的结果就是转换说明对应到内存中的存储结构表现出来的数据输出。

这里我们举个简单的例子

![image-20201202064914593](https://raw.githubusercontent.com/inconspicuousy-start/image/master/image-20201202064914593.png)

代码演示

```c
#include <stdio.h>
#define PAGES 336
#define WORDS 65618

/**
 * 转换说明不匹配问题
 * @return
 */
int main(void) {

    short num = PAGES;
    short mnum = -PAGES;

    // 这里 num 是正数,对于符号位的转换可忽略
    printf("num as short and unsigned short: %hd, %hu \n", num, num);
    // mnum是负数,本身前面一位代表着符号位, 但是unsigned short会将前面一位参与计算
    // 所以最后表现出来的就是 数据转换为正数
    printf("-num as short and unsigned short: %hd, %hu \n", mnum, mnum);
    // 因为num占2个字节,char占一个字节,所以num会先被截取成一个字节然后转换成对应的字符
    printf("num as int and char: %d, %c \n", num, num);
    // int占4个字节,short占两个字节所以同样把多余的两个字节截取到后转换成对应的short值
    printf("WORDS as int, short, char: %d, %hd, %c \n", WORDS, WORDS, WORDS);
    return 0;
};
```

输出结果

```
num as short and unsigned short: 336, 336 
-num as short and unsigned short: -336, 65200 
num as int and char: 336, P 
WORDS as int, short, char: 65618, 82, R
```

> 注意：为什么-336转成unsigned short会是65200呢？涉及到计算机存储负数时是以补码的方式存储的。
>
> -336（原码）： 1000 0001 0101 0000
>
> -336（反码）： 1111 1110 1010 1111 （直接将原码除符号位外的其他位数取反）
>
> -336（补码）： 1111 1110 1011 0000 （反码的末位+1）
>
> 所以当转成无符号整数时，会直接将（1111 1110 1011 0000）转化成对应的整数为65200。

- #### 参数传递

代码演示

```c
#include <stdio.h>
/**
 * 参数传递
 * @return
 */
int main(void) {
    float n1 = 3.0F;
    double n2 = 3.0;
    long n3 = 2000000000;
    long n4 = 1234567890;
    printf("%ld, %ld, %ld, %ld", n1, n2, n3, n4);
    return 0;
};
```

输出结果

```
2000000000, 1234567890, 140732868995968, 0
```

从输出结果来看，跟我们想象中的完全不一样！为什么n1、n2以long型输出却输出的是n3、n4的值，而n4的值却是0。

这里得从C语言的中的参数传递方式。

执行 `printf("%ld, %ld, %ld, %ld", n1, n2, n3, n4)`语句的步骤。

1. 计算机把变量n1, n2, n3, n4的值传递给程序。
2. 程序根据变量类型（不是根据转换说明）把这些值放入到栈（stack）的内存区域。
3. 由于float类型在计算时自动转换成double类型，所以n1被存储到栈中占8个字节；n2占8个字节；而n3和n4分别占用4个字节。
4. 然后控制转到printf函数，该函数根据转换说明（不是根据变量类型）从栈中读取值。`%ld`转换说明表明printf应该读取4字节，所以printf分别4次读取栈中的4个字节，即会读取16个字节。由于不同的系统实现该读取方式不一致，猜测此处先读取的n3、n4在读取的n1的8个字节。由于float与整数的存储方式不一致，所以导致最后一次输出为0。

> 注意：从C语言的传递参数的方式来看，我们在处理转换说明时，一定要与数据类型对应，否则不止影响的是不匹配的数据打印，还会影响后续的数据打印。

- #### printf函数的返回值

大部分C函数都有一个返回值，这是函数计算并返回给主调程序的值。

printf函数返回一个整数，当输出正确时返回打印字符的个数；当输出错误时，返回一个负值。

printf函数返回值是其打印输出功能的附带用途，通常很少用到，但是在检查输出错误时可能会用到。比如在写入文件时很常用，当文件拒绝写入时，我们就可以处理拒绝的逻辑。

### 5.2 scanf函数

C库包含了多个输入函数，scanf是最通用的一个，因为它可以读取不同格式的数据。	

scanf函数的作用？因为从键盘输入的值都是文本字符串，所以scanf函数必须把输入的字符串转换成指定的整数、浮点数、字符或者字符串。

scanf函数和printf函数类似，也是使用格式字符串和参数列表。scanf函数中的格式字符串表明字符输入流的目标数据类型；scanf函数的参数列表使用指向变量的指针。

指针的特点：

- 如果用scanf函数读取基本变量类型的值，在变量名前加上一个&；
- 如果用scanf函数吧字符串读入字符数组中，不要使用&;

代码示例

```c
#include <stdio.h>
/**
 * scanf函数的使用
 * @return
 */
int main(void) {

    int age;
    float asset;
    char pet[30];

    printf("输入你的年龄,体重和爱好. \n");
    scanf("%d %f", &age, &asset);
    scanf("%s", pet);

    printf("%d $%.2f%s\n", age, asset, pet);

    return 0;
}
```

输出结果

```
输入你的年龄,体重和爱好. 
38 92360.88 lla ma
38 $92360.88lla
```

从代码中我们可以看到对普通数据类型的变量赋值时要使用 `&` 符号，但是对数组、字符串的赋值不需要使用 `&`符号。

从输出结果上来看，当前通过终端输入时，每输入一个数据通过空格就可以实现对下一个数据的进行赋值，所以就有 `scanf函数使用空白、换行符、制表符和空格把输入分成多个字段`。

> 注意，如果转换字符是 `%c`的话，scanf函数会读取每个字符，包括空白。

- #### Scanf函数的转换说明

scanf函数的所用的转换说明与printf函数几乎相同。主要是的区别在于对于float、double类型，printf使用%f、%e、%E、%g、%G转换说明，而scanf只把它们用于float类型，对于double类型时要使用 `l`修饰符。

常用的转换说明

| 转换说明                       | 含义                             |
| ------------------------------ | -------------------------------- |
| %c                             | 把输入解释成字符                 |
| %d、%i                         | 把输入解释成有符号的十进制整数   |
| %e、%f、%g、%a、%E、%F、%G、%A | 把输入解释成浮点数               |
| %o                             | 把输入解释成有符号八进制整数     |
| %p                             | 把输入解释成指针、地址           |
| %s                             | 把输入解释成字符串               |
| %u                             | 把输入解释成无符号十进制整数     |
| %x、%X                         | 把输入解释成有符号的十六进制整数 |

常用的转换说明修饰符

| 转换说明 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| *        | 抑制赋值                                                     |
| 数字     | 最大字段宽度。输入达到最大字段宽度处，或第一次遇到空白字符时停止。示例："%10s" |
| hh       | 把整数作为signed char 或unsigned char类型读取。示例："%hhd" 、"%hhu" |
| ll       | 把整数作为long long 或者 unsigned long long 类型读取。示例："%lld"、"%llu" |
| h、l、L  | "%hd"和"%hi"表明把对应的值储存位short int类型。<br>"%ho"、"%hx"、"%hu"表明把对应的值储存为unsigned shot int类型。<br>"%ld"、"%li"表明把对应的值储存为long类型。<br>"%lo"、"%lx"、"%lu"表明把对应的值储存为unsigned ling类型。<br>"%le"、"%lf"、"%lg"表明把对应的值储存为double类型。<br>在e、f、g前面使用L而不是l，表明把对应的值被存储为long double类型。如果没有修饰符，d、i、o和x表明对应的值被存储为int类型，f和g表明把对应的值储存为float类型。 |
| j        | 在整型转换说明后，表明使用intmax_t或unintmax_t类型。         |
| z        | 在整数转换说明后，表明使用sizeof的返回类型。                 |
| t        | 在整数转换说明后，表明使用表示两个指针差值的类型。示例："%td"、"tx" |

- #### Scanf函数读取数据的流程

这里我们的假设scanf函数根据一个%d转换说明读取一个整数。

1、scanf函数每次读取一个字符。

2、开始读取时会跳过所有的空白字符，直到遇到第一个非空白字符才开始读取。

3、因为读取整数，所以scanf发现一个数字字符或者+-符号时便保存该字符，并读取下一个字符。

4、如果遇到一个非数字字符便认为读到了整数的末尾。

5、scanf将读取的数字或+-符号转换成数值计算后放入到指定的变量中。

> 注意：
>
> 1、如果使用字段宽度，scanf会在字段结尾或者第一个空白字符处停止读取。
>
> 2、如果第一个非空白字符是A而不是数字，那么表示此次读取数据失败，当前scanf函数会停止读取输入。
>
> 3、如果上一个scanf函数读取失败，下一个scanf函数会从上一个scanf读取失败的地方继续读取。

代码演示

```c
#include <stdio.h>
/**
 * scanf函数的使用
 * @return
 */
int main(void) {

    int age;
    char str[20];
    char str1[20];
    // 当前scanf函数会读取失败, 所以age,str都不会被赋值
    scanf("%d %s", &age, str);
    printf("%d, %s\n", age, str);

    // 当前scanf函数会从上一个scanf函数失败的地方继续读取
    scanf("%s", str1);
    printf("%s\n", str1);


    return 0;
}
```

结果输出

```
A123
179007488, 
A123
```

A123是我当前输入的值，scanf读取整数失败，导致scanf函数退出，下一个scanf函数从A开始读起。当前age输出的是内存中的随机值。

- #### 格式字符串中的普通字符

scanf函数允许把普通字符放在格式字符串中，除空格字符外的普通字符必须与输入字符串严格匹配。

简单来说，比如格式字符串为 `"%d,%d"`那么在用户输入时必须在两个整数之间添加逗号作为分隔符。指定注意的是，因为scanf函数读取字符时是忽略空白字符的，所以两个整数之间的空白字符都会被忽略。

因为scanf函数读取字符时，本身就是忽略空白字符的，所以格式字符串中的空白字符本身就会被忽略。也就是说 `"%d%d"`等价于 `"%d   %d"`。

> 注意，虽然%c可以读取包括空白字符的任意字符，但是如果在%c转换说明之前加上空格，那么scanf读取时会读取第一个非空白的字符进行赋值。比如，`" %c"`。

- #### Scanf函数的返回值

scanf函数返回成功读取的项数。如果没有读取任何项，且需要读取而用户却输入一个非数值字符串，scanf变返回0。当scanf检测到`文件结尾`时，会返回`EOF`（EOF时stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。一般scanf函数的返回值用来检测和处理不匹配的输入。

> 注意：成功读取的项数表示成功赋值了多少个变量， 而不是读取了多少个字符。

### 5.3 printf函数和scanf函数的*修饰符

print函数和scanf函数都可以使用*修饰符来修改转换说明的含义。

#### 5.3.1 printf函数的*修饰符

`*修饰符`可以结合参数来控制输出字段的宽度。比如，如果转换说明是 `"%*d"`，那么可以通过参数来指定*的值。

- 代码示例

```c
#include <stdio.h>
/**
 * printf函数*修饰符的使用
 * @return
 */
int main(void) {

    unsigned width, precision;
    int number = 256;
    double weight = 242.5;

    printf("请输入number字段宽度:\n");
    scanf("%d", &width);
    printf("number = %*d\n", width, number);

    printf("请输入weight字段长度和小数部分字段宽度:\n");
    scanf("%d %d", &width, &precision);
    printf("weight = %*.*f\n", width, precision, weight);


    return 0;
}

```

- 输出结果

```
请输入number字段宽度:
6
number =    256
请输入weight字段长度和小数部分字段宽度:
8 3
weight =  242.500
```

这里可以看出，当给定的字段长度大于实际的数值长度时，处理方式与转换说明修饰符中直接给定数字一致，会用空格进行补充；而对于浮点数小数部分来说，不足的部分用0补充。

#### 5.3.2 scanf函数的*修饰符

在scanf函数中，`*修饰符`放在%和转换字符之间，会使得scanf函数跳过该输出项。

在程序需要读取文件中特定列的内容时，这项跳过功能很有用。

- 代码演示

```c
#include <stdio.h>
/**
 * scanf函数*修饰符的使用
 * @return
 */
int main(void) {

    int n;
    printf("请输入三个整数:\n");

    scanf("%*d %*d %d", &n);
    printf("这个最大的整数是 %d\n", n);

    return 0;
}
```

- 输出结果

```
请输入三个整数:
2013 2014 2015
这个最大的整数是 2015
```

### 5.4 printf常用用法

- 通过数字修饰符或者*修饰符指定多个变量的输出宽度一致，输出时会显得更美观，这样多行展示时，会有表格的形式。
- 格式化浮点型数据，使得输出更美观。
- 本地化设置。因为不同的地方对于数字的展示形式不同，因此C程序可以选择特定的本地化设置。

