# C Primer Plus之运算符、表达式和语句

## 1. 循环

### 1.1 white循环

- 代码演示

```c
#include <stdio.h>

// 定义一个鞋码的调整基数
#define ADJUST 7.31
/**
 * while循环
 * 计算多个鞋码对应的脚长
 * @return
 */
int main(void) {

    // const 常量
    const double SCALE = 0.333;
    double shoe, foot;

    printf("鞋子大小对应脚的大小 \n");
    shoe = 3.0;
    // while循环
    while (shoe < 18.5) {
        foot = SCALE * shoe + ADJUST;
        printf("%10.1f %15.2f\n", shoe, foot);
        shoe += 1.0;
    }

    return 0;
}
```

- 输出结果

```
鞋子大小对应脚的大小 
       3.0            8.31
       4.0            8.64
       5.0            8.97
       6.0            9.31
       7.0            9.64
       8.0            9.97
       9.0           10.31
      10.0           10.64
      11.0           10.97
      12.0           11.31
      13.0           11.64
      14.0           11.97
      15.0           12.30
      16.0           12.64
      17.0           12.97
      18.0           13.30
```

## 2. 基本运算符

C用运算符表示算数运算。

### 2.1 赋值运算符

```
=
```

赋值运算符的作用是把值存储到内存位置上。

用于存储值的数据存储区域统称为数据对象。

赋值运算符左侧必须引用一个存储位置，常见的也就是变量名、指针（指针可以用指向一个存储位置）。

> 注意：数据的初始化并不是赋值。

#### 2.1.1 相关术语

> 1、`数据对象`：用于存储值的数据存储区域统称为数据对象。
>
> 2、`左值（lvalue）`：用于标识特定数据对象的名称或表达式。简单来说，对象指的是实际的数据存储，而左值是用来标识或者定位存储位置的标签。
>
> 3、`可修改的左值`：也叫对象定位值。用于标识可修改的对象。赋值运算符的左侧应该是可修改的左值。值得注意的是，const限定符创建的变量不可修改，所以const创建的变量是左值，但是是，不是可修改的左值。const限定符创建的变量的操作为数据的初始化，而不是数据的赋值操作。
>
> 4、`右值（rvalue）`：指的是能赋值可修改左值的量，且本身不是左值。右值可以是常量、变量、其他可求值的表达式（如，函数调用）。
>
> 5、`运算对象（operand）`：也叫做项。运算对象是运算符操作的对象。运算符左侧的运算对象应该是可修改的左值。

- 简单示例

```c
		int ex;
    int why;
    int zee;

    const int TWO = 2;
    why = 42;
    zee = why;

    ex = TWO * (why + zee);
```

1、`ex、why、zee`都是可修改的左值，他们可用于赋值运算符的左侧和右侧。

2、`TWO`是不可改变的左值，他只能用于赋值运算符的右侧。

3、`42`是右值，他不能引用某指定的内存位置。

4、表达式`why+zee`是右值，该表达式不能表示特定的内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。

### 2.2 加法运算符

```
+
```

加法运算符（addition operator）用于加法运算，使其两侧的值相加。

相加的值（运算对象）可以是变量、也可以是常量。

### 2.3 减法运算符

```
-
```

减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。

> 注意：加法、减法运算符都被称为二元运算符（binary operator），即这些运算符需要两个运算对象才能完成。

### 2.4 符号运算符

符号运算符也叫做一元运算符（unary operator），即一元运算符只需要一个运算对象。常用的符号运算符有 `+、-`。

正号运算符不会改变运算对象的值或符号，符号运算符用于标明或改变一个值的代数符号。

### 2.5 乘法运算符

```
*
```

乘法运算符用于乘法运算，使其两侧的值相乘。

### 2.6 除法运算符

```
/
```

除法运算符用于除法运算。

> 注意：
>
> 1、整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。整数除法结果的小数部分被丢弃，这一过程被称为 `截断（truncation）`。
>
> 2、当发生截断时不是将小数点四舍五入，而是直接舍弃。
>
> 3、混合整数和浮点数计算的结果是浮点数。计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。

## 3. 基本运算符的优先级

当运算符共享一个运算对象时，优先级决定了求值顺序，优先级高的先执行，遇到相同的优先级会按照结合律来计算表达式（一般是从左往右）。

基本运算符优先级如下（优先级从高到低）。

| 运算符       | 结合律   |
| ------------ | -------- |
| （）         | 从左往右 |
| +、-（一元） | 从右往左 |
| *、/         | 从左往右 |
| +、-（二元） | 从左往右 |
| =            | 从右往左 |

比如，表达式`12/3*4`中 `*/`的优先级相同，那么按照 `*/`的结合律来计算表达式，先算 `12/3`再算 `4*4`。

### 3.1 优先级和求值顺序

运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。

比如：`1*5+3*6`这里运算对象5是 `*+`两个运算符的共享对象，所以优先级高的 `*` 会先计算，同理运算对象3的 `*`会优先执行。但是是先执行 `1*5`还是先执行 `3*6`，C语言并没有规定，不同的执行器可能执行方式不同。

- 代码演示

```c
#include <stdio.h>

/**
 * 运算符的优先级
 * @return
 */
int main(void) {

    int top, score;
    // 括号 > 符号 > 乘除 > 加减 > 赋值
    // -7 * 6 + (4+3*5) => -42 + 19 => -23
    top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3));
    printf("top = %d, score = %d \n", top, score);

    return 0;
}
```

- 输出结果

```
top = -23, score = -23 
```

## 4. 其他运算符

### 4.1 sizeof运算符和size_t类型

sizeof运算符以字节为单位返回运算对象的大小。

运算对象可以是具体的数据对象（如，变量名）或类型。

如果运算对象是类型（如，float），则必须用圆括号将其括起来。

#### 4.1.1 sizeof 的返回值类型

sizeof返回size_t类型的值。这是一个无符号整数类型，但它不是新类型，C有一个typedef机制，允许程序员为现有类型创建别名。例如，`typedef double real;`这样，real就是double 的别名。

#### 4.1.2 size_t的转换说明

size_t数据类型的转换说明为 `%zd`，也就是说，可以通过 `%zd`来打印sizeof 的返回值。

#### 4.1.3 代码示例

```c
#include <stdio.h>

/**
 * sizeof运算符
 * @return
 */
int main(void) {

    int n = 0;
    size_t intsize;
    intsize = sizeof(int);

    printf("n = %d, n has %zd bytes;all ints have %zd bytes.\n", n, sizeof n, intsize);

    return 0;
}

```

- 输出结果

```
n = 0, n has 4 bytes;all ints have 4 bytes.
```

### 4.2 求模运算符

```c
%
```

求模运算符（modulus operator）用于整数运算。求模运算符只能用于整数，不能用于浮点数。

求模运算符给出其左侧除以右侧整数的余数（remainder）。

> 注意：
>
> 对于负数求模，如果第一个运算对象是负数，那么求模的结果为负数；如果第一个运算对象是正数，那么求模的结果也是正数。
>
> - 11%-5  =  1
> - -11%-5 = -1 

### 4.3 递增、递减运算符

```c
++、--
```

递增运算符（increment operator）将其运算对象递增1。

递减运算符（decrement operator）将其运算对象递减1。

- 前缀模式，++、--出现在其作用的变量前面。
- 后缀模式，++、--出现在其作用的变量后面。

前缀模式和后缀模式的区别在于，前缀模式表示对应的运算对象先+、-1后执行其他逻辑；后缀模式表示对应的运算对象先参与计算逻辑后+、-1。

- 代码示例

```c
#include <stdio.h>

/**
 * 递增递减运算符
 * @return
 */
int main(void) {

    int a = 1;
    // 现将a+1后赋值给b
    int b = ++a;
    a = 1;
    // 现将a赋值给c在将a+1
    int c = a++;

    a= 1;
    // 现将a-1后赋值给d
    int d = --a;
    a = 1;
    // 现将a赋值给e在将a-1
    int e = a--;
    a = 1;

    printf("a = %d, b = %d, c = %d, d = %d, e = %d", a, b, c, d, e);



    return 0;
}

```

- 结果输出

```
a = 1, b = 2, c = 1, d = 0, e = 1
```

#### 4.3.1 递增递减运算符的优先级

递增、递减运算符只有圆括号的优先级比他们高。

值得注意的是，递增、递减针对的是运算对象本身而不是运算对象参与的表达式。简单来说就是，如果是后缀模式，运算对象只有参与完所有的计算后才会递增。例如，`（y+n++）*6`这里会先计算完 `（y+n）*6`最后才会将n的值+1。

> 注意：
>
> 1、不要在printf参数列表中使用递增运算符。printf参数列表中参数表达式执行的先后顺序不可控，可能后面的参数表达式先执行，这样在打印前面的值时可能会被后面的参数表达式中的递增、递减运算符影响。
>
> 2、我们在基本运算符 的优先级中谈到过，对于一个运算符左侧的表达式和右侧表达式计算的先后顺序不可控，所以两侧的表达式中如果出现同一个变量具有递增或者递减运算符，可能会对另一边的表达式有影响。比如，`a*2+5*(a++)`，右边的表达式可能先执行导致左边的a 的值计算不可控。

#### 4.3.2 递增递减运算符的使用规则

- 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或者递减运算符。
- 如果一个变量多次出现在一个表达式中，不要对该变量使用递增递减运算符。

## 5. 表达式和语句

### 5.1 表达式

表达式（expression）由运算符和运算对象（运算符操作的对象）组成。

最简单的表达式是一个单独的运算对象。

### 5.2 语句

语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，不部分语句都以分号结尾。

比如，`legs = 4`这只是一个表达式，`legs = 4;`这个才是语句。

最简单的语句是空语句 `;`。

C把末尾加上一个分号的表达式都看作是一条语句。比如，`8;`这个也是语句。

### 5.3 代码示例

```c
#include <stdio.h>

/**
 * 计算前20个整数的和
 * @return
 */
int main(void) {

    // 声明语句
    int count, sum;
    // 表达式语句
    count = 0;
    sum = 0;
    // 迭代语句
    while (++count <= 20) {
        sum += count;
    }
    // 表达式语句
    printf("sum = %d\n", sum);

    // 跳转语句
    return 0;
}

```

输出结果

```
sum = 210
```

### 5.4 序列点

序列点（sequence point）是程序执行的点。在C语言中语句的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符、递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。

比如，`y = （4+x++） + (6+x++);`，这里 `4+x++`是整个完整表达式序列点的一个子表达式，所以此处的x++不会立即执行，同理 `6+x++`中的x++也不会立即执行。等到赋值表达式结束后，x++在分别执行，整个表达式语句就结束了。

### 5.5 复合语句

复合语句（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为块。

### 5.6 类型转换

通常，在语句和表达式中应使用类型相同的变量和常量。类型转换就负责处理语句和表达式中类型不同的混合类型，将混合类型转换成相同类型进行运算。

#### 5.6.1 类型转换的基本规则

- `升级（promotion）`：特点是由较小类型转换为较大类型。比如，当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int；如果short与int的大小相同，unsigned short会被转换成unsigned int。
- 涉及到两种类型的运算，两个值会被分别转换成两种类型的更高级别。
- 类型的级别从高到低依次是long double、double float、float、unsigned long long、long long、unsigned long、long、unsigned int、int。特例，当 long和int的大小相同时，unsinged int比long的级别高。之所以short和char类型没有列出，是因为他们已经被升级到int、unsigned int。
- 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程导致升级或者降级（demotion）。所谓的降级，是指把一种类型转换成更低级别的类型。类型升级通常都不会有什么问题，但是类型降级由于较低类型可能放不下整个数字那么最终会导致数据被截断。比如，8位的char类型变量存储整数101没问题，但是放不下22334。
- 当作为函数参数传递时，char和short被转换成int，float被转换成double。函数参数传递的类型转换，会覆盖自动升级。这就说明为什么printf函数中float数据会先转换成double数据后进行输出了。

#### 5.6.2 待赋值的值与目标类型类型转换规则

当赋值的值与目标类型不匹配时发生类型转换的规则。

- 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。
- 如果目标类型时一个有符号整型，且待赋的值是整数，结果因实现而异。
- 如果目标类型是一个整型，且待赋的值是浮点型，该行为是未定义的。

如果把浮点型转换成整数类型，浮点型会被降级为整数类型，原来的浮点值会被截断。例如，23.12和23.99都会被截断为23，-23.5会被阶段为-23。

#### 5.6.3 代码示例

```c
#include <stdio.h>

/**
 * 类型转换
 * @return
 */
int main(void) {

    char ch;
    int i ;
    float fl;

    // 赋值表达式类型不匹配触发类型转换,直接将被赋值转换成目标类型
    // 因为从右向左都是低->高,那么都是升级.
    fl = i = ch = 'C';
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);

    // 1默认是整数, 表达式中类型不匹配触发类型转换
    // 会先将ch的值转换成int然后与1进行运算后,再将int的值转换成char
    ch = ch + 1;
    i = fl + 2 * ch;
    fl = 2.9 * ch + i;
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl);

    // 超过范围发生截断
    ch = 1107;
    printf("now ch = %c \n", ch);
    ch = 80.80;
    printf("now ch = %c \n", ch);

    return 0;
}

```

- 输出结果

```
ch = C, i = 67, fl = 67.00
ch = D, i = 203, fl = 400.20
now ch = S 
now ch = P 
```

#### 5.6.4 强制类型转换运算符

```c
（type）
```

强制类型转换避免了自动类型转换，将值转化成指定的类型。

强制类型转换就是在需要转换的值的前面放置用圆括号括起来的类型名。圆括号+类型名构成了强制类型转换运算符（cast operator）。

```c
int mice = 1.6 + 1.7；
int mice = （int）1.6 + （int）1.7；
```

第一句使用自动类型转换，先1.6+1.7计算出double值，然后将double转换成int型；而第二句使用强制类型转换，首先将1.6和1.7分别转换成int然后将转换后的结果进行相加。

## 6. 带参数的函数

### 6.1 代码示例

```c
#include <stdio.h>

// 函数的声明, 函数只有声明了才能够调用
void pound(int n);

/**
 * 带参数的函数
 * @return
 */
int main(void) {

    int times = 5;
    char ch = '!';
    float f = 6.0f;

    // int类型的参数
    pound(times);
    // 数据类型会被自动升级(自动向上转型), 类似于 pound((int) ch)
    pound(ch);
    // 自动向下转型, 类似于 pound((int) f)
    pound(f);

    return 0;
}

/**
 * 自定义带参数的函数
 *
 * @param n
 */
void pound(int n) {
    while (n-- > 0) {
        printf("#");
    }
    printf("\n");
}
```

- 输出结果

```
#####
#################################
######

```

