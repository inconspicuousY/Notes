# C Primer Plus之数据

> 本节文档主要讲解C语言中数据类型有关的知识。

## 1. 示例程序

```c
/**
 * 了解C语言的数据类型
 * @author inconspicuousy
 * @date 2020/11/6
*/
#include <stdio.h>

int main(void) {
    // weight 体重
    // value 相等重量的白金价值
    float weight, value;

    printf("你知道与你相等体重的白金的价值吗？\n");
    printf("让我们来核查一下。\n");
    printf("请输出你的体重：");

    // 获取用户的输入，将输入的值转换成浮点类型
    scanf("%f", &weight);
    // 将体重转化成盎司单位后， 1盎司约等于1700美金
    // 这里默认1700.0是double类型，从double类型转换成float会警告可能会丢失数据
    value = 1700.0 * weight * 14.5833;

    printf("相等体重的白金的的价值为$%.2f。\n", value);
    printf("你是如此的值钱，\n");
    printf("吃的更多保持你的价格吧。\n");

    return 0;
}
```

### 1.1 程序剖析

- 浮点型变量的声明

```c
float weight, value;
```

这里声明了两个浮点型数据类型的变量。

- 浮点型数据类型的格式化输出

```c
printf("相等体重的白金的的价值为$%.2f。\n", value);
```

这里通过 `%f` 占位符来表明该处将处理一个浮点型数据，`.2f`控制浮点数的精度，最后将浮点数保留两位小数输出。

> 注意：
>
> 当占位符明确表示该处将以浮点数处理，而传参是一个整数类型时，因为在C语言中，整数和浮点数的存储方式不一致，所以会导致得不到理想中结果。
>
> ```c
> #include <stdio.h>
> 
> int main(void) {
>     int a = 1;
>     printf("%.2f", a);
> }
> ```
>
> 此处输出的结果为：
>
> ```
> 0.00
> ```

- 读取键盘的输入

```c
scanf("%f", &weight);
```

scanf函数主要用于读取键盘的输入，该条语句的作用有两个：

1. `%f`表示将用户输入的值转化成浮点数。
2. `&weight`告诉scanf函数把输入的值直接赋值给weight变量，`&`符号的作用是帮助scanf函数找到weight的地址。

- 变量和常量

```c
value = 1700.0 * weight * 14.5833;
```

这里的1700.0、14.5833就是常量，value、weight就是变量。

> 1、变量，在程序运行期间可能会改变或被赋值的值。
>
> 2、常量，在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化的值。

## 2. 位、字节、字、字长的概念

位、字节、字都是描述计算机数据单元或存储单元的术语。

| 单位 | 描述                                                         |
| ---- | ------------------------------------------------------------ |
| 位   | 位（bit）是`计算机中存储的最小单位`，可以存储0或1，位也是计算机内存的基本构建块。 |
| 字节 | 字节（byte）是`常用的计算机存储单元`，1字节均为8位，即1byte=8bit。 |
| 字   | 字（word）是 `设计计算机时给定的自然存储单位`，一个字通常由一个或多个字节构成。 |
| 字长 | 计算机的每个字所包含的位数（bit）称为字长。根据计算机的不同，字长有固定的和可变的两种。<br/>1、固定字长：字长度不论什么情况都是固定不变的；<br/>2、可变字长：在一定范围内，其长度是可变的。<br/>计算机的字长是指他一次可处理的二进制数字的数目。平时我们所说的32位计算机、64位计算机就是指计算机的字长。计算机的字长越长，就表示一次可处理的数据越多，性能越好。 |

## 3. 数据类型

### 3.1 数据类型关键字

| 最初的关键字 | C90标准添加的关键字 | C99标准添加的关键字 |
| ------------ | ------------------- | ------------------- |
| int          | signed              | _Bool               |
| long         | void                | _Complex            |
| short        |                     | _Imaginary          |
| unsigned     |                     |                     |
| char         |                     |                     |
| float        |                     |                     |
| double       |                     |                     |

> 注意：
>
> 上述关键字不是说C语言只有这么多数据类型，他们大多数是可以联合使用的。

### 3.2 数据类型

C语言中数据类型大致分为以下几种：

| 整数     | 浮点数 | 字符 | 布尔  | 复数     | 虚数       |
| -------- | ------ | ---- | ----- | -------- | ---------- |
| int      | float  | char | _Bool | _Complex | _Imaginary |
| long     | double |      |       |          |            |
| short    |        |      |       |          |            |
| unsigned |        |      |       |          |            |
| signed   |        |      |       |          |            |

> 注意：
>
> 1、char也可以表示较小的整数（依赖于unicode码）。
>
> 2、用int关键字表示基本的整数类型，用long、short、unsigned、signed提供基本整数类型的变式。
>
> 3、有些数据类型关键字可以联合使用，比如，long long int、unsign short int、long double等。

### 3.3 数据类型的存储方式。

通过数据类型关键字创建的类型，按照计算机的存储方式可分为两个基本类型。

- 整数类型

在C语言中，整数就是没有小数部分的数，计算机以二进制的数字存储整数。

- 浮点数类型

在C语言中有几种类型数字表示浮点数。

1. 有小数点的数就是浮点数（注意，即使小数点后面没有数字，那么这个值也是浮点数）。
2. e计数法，比如3.14E7表示3.14*10^7。
3. 用十六进制表示浮点类型。在十六进制数钱加上十六进制前缀（0x或者0X），用p或者P分别代替e和E，用2的幂代码10的幂（即p计数法）。比如 `0xa.1fp10`，解读分为整数部分和小数部分还有指数部分。

| 部分     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 整数部分 | 整数部分解读和16进制的整数解读一致。即a表示10。              |
| 小数部分 | 小数部分，分母从16^1开始计算。0.1f就表示 1/16+15/16^2 = 1/16+15/256 |
| 指数部分 | 指数部分也就是直接表示2的指数。p10就表示2^10。               |

计算机把浮点数分成小数部分和指数部分来表示，而且分开存储这两部分。

在十进制下，可以把7.0转化成0.7E1，0.7是小数部分，1就是指数部分。

下面就是计算机中存储π的方式：

![](https://raw.githubusercontent.com/inconspicuousy-start/image/master/20201117223544.png)

> 注意：
>
> 1、因为浮点数和整数的存储方案不同，所以虽然7和7.00在数值上相同，但是他们的存储方式不同。
>
> 2、根据浮点数的存储方式来看，因为浮点数是依赖指数存储的，所以浮点数可以表示的范围比整数大。
>
> 3、浮点数只是实际值的近似值，比如7.0可能就被存储成浮点数6.99999。所以浮点数的计算一般都涉及到精度损失。

## 4. 整数数据类型的取值范围

在声明某个变量时，都会依据变量的数据类型在内存中分配指定的内存空间，该内存空间决定了该数据类型的取值范围。

下面是某些数据类型所占用的内存空间以及数据的取值范围。

| 数据类型                  | 内存空间                                                     | 取值范围                                                     |
| ------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| int                       | 一般情况下占用一个字长；但是当计算机的字长小于16位时，就需要占用更多个字长。换句话说，就是最少就是16位；目前的计算机一般都是32位或者是64位，所以一般存储int型整数占用32位或者64位。int 类型的宽度要么和long类型相同、要么和short类型相同。 | 最小占用16位内存空间，所以最小的取值范围为 -32767~32767，随着计算机的字长越大，取值范围也就越大。 |
| short                     | short是short int的简写，占用的存储空间可能比int小            | 最小占用16位内存空间，最小取值范围[−32767,32767]             |
| long、long int            | 占用的存储空间可能比int 多                                   | 最小占用32位内存空间，对于32位机，long的最小取值范围 是[−2147483647,2147483647] |
| long long int 、long long | 占用的存储空间可能比long 多                                  | 该类型至少占用64位                                           |
| unsigned int、unsigned    | 只表示正整数，一般来说，因为int 的符号位被用来表示实际数值，所以无符号整型可以表示更大的数。 | 最小取值范 围是[0,65535]                                     |

> 注意：
>
> 1、变量在声明时就分配了指定的内存空间，即使没有被初始化赋值。
>
> 2、为什么其他整数类型的变量与int整数类型比较来看，都是可能大或者小于int的存储空间，是因为不同的字长的计算机存储某种数据类型可能会不一致。
>
> 3、一般来说，short占用16位，int占16位或者32位，long 占32 位，long long 占用64位。
>
> 4、如果需要定义一个32位的整数，应当考虑使用long来定义，因为这样不管是在16位计算机还是在32位计算机中都可以达到表示32位整数；而使用int的话，在16位计算机上int只能表示16位，就会出现数据丢失。
>
> 5、在需要定义16位的值时，如果不考虑特别注重内存，使用int即可；特别注重内存的话就要使用short。

程序代码中如果没有经过声明直接使用的整数，默认会使用int，超出int的范围会使用long int，依次是 unsigned long、long long、unsigned long long。特别的，如果想要不使用默认行为，比如强制使用long存储整数，那么在整数的后面加上L即可，其他的long long 就用LL，unsigned就用U表示。

| 数据类型           | 强制表示 | 占位符                                                       |
| ------------------ | -------- | ------------------------------------------------------------ |
| short              |          | %hd、%ho（以八进制的格式打印short类型的整数）、%hx（以十六进制的格式打印short类型的整数） |
| unsigned           | U        | %u                                                           |
| long               | L        | %ld、%lo、%lx                                                |
| unsigned long      | UL       | %lu                                                          |
| long long          | LL       | %lld                                                         |
| unsigned long long | ULL      | %llu                                                         |

要理解为什么格式化打印整数十进制数据类型时，结尾都会带上d，这是因为其实对于short、long、long long来说都是short int之类的缩写。

## 5. 八进制和十六进制的表示方式

| 进制     | 特定前缀   | 占位符    | 带特定前缀占位符 |
| -------- | ---------- | --------- | ---------------- |
| 十进制   | 无         | %d        | %d               |
| 八进制   | 0（数字0） | %o        | %#o              |
| 十六进制 | 0x 或0X    | %x 或者%X | %#x 或者 %#X     |

- 代码

```c
#include <stdio.h>

int main() {
    int a = 21;
    int b = 021;
    int c = 0x21;
    printf("%d, %o, %x, %d\n", a, b, c, c);
    printf("%#o, %#x", b, c);
}
```

- 执行结果

```shell
21, 21, 21, 33
021, 0x21
```

我们从输出结果另外可以看出来，将十六进制以十进制输出时，会自动进行转换后输出。

## 6. 整数溢出

整数溢出表示整数超过了声明的数据类型的取值范围。一般情况下，整数最大值与最小值形成闭环，当超出最大值时，那么就会从最小值开始往上数。比如：

- 有符号整数的int，如果在32位机或者64位机上，最大的取值为2147483647，如果整数被赋值2147483648那么就会是最小值 -2147483647。
- 无符号整数的unsigned int，如果在32位机或者64位机上，最大的取值为4294967295，如果被赋值4294967296的话那么就会是最小值0。

代码演示

```c
#include <stdio.h>

int main() {
   int a = 2147483648;
   unsigned int b = 4294967296;

    printf("%d, %u", a, b);
}
```

执行结果

```
-2147483648, 0
```

## 7. 基本数据类型之char类型

char类型用于存储字符，如字母或者标点符号。

char类型也可以存储比较小的整数。

> 注意：
>
> 1、虽然char类型在表现上来看存储的是字符，但是从技术层面上来看，char是整数类型。因为char类型在计算机底层中实际存储的是整数而不是字符，用特定的整数表示特定的字符。
>
> 2、什么样的整数表示什么样的字符，一般都是参照的ASCII编码。比如在ASCII码中，A字符用65表示，所以在代码中声明char型变量的值为A时，实际上计算机底层存储的是65。
>
> 3、基于char类型实际存储的是整数，所有char类型也可以当做存储比较小的整数的类型。

### 7.1 char型数据取值范围

char类型被定义为8位的存储单元，占用一个字节。

基于占用一个字节，所以char类型表示较小整数时，取值范围也是有限的。

系统实现char类型的方式不同，char类型能表示整数的取值范围也不同，而不同点在与八位字节的最前面一位是否是符号位。如果是符号位，取值范围也就是-128~127；如果不是符号位，取值范围也就是0~255。

- 代码演示

```c
#include <stdio.h>

int main(void) {
    // 此时a虽然被赋值为128，但是由于当前系统的char表示的整数是有符号位的，所以实际上，char被存储的整数为-128。
    char a = 128;
    printf("%d", a);

    return 0;
}
```

- 输出结果

```
-128
```

> 注意：
>
> 1、char型数据只占用8位存储单元，当char型数据被声明的整数大于一个字节，会自动截取只取最后一个字节作为char类型的值。
>
> 2、特别的，当我们定义一个char类型数据为多个字符时，只会取最后一位有效的字符。比如，当我们定义一个char型数据为'FATE'时，其实有效的就是'E'字符。
>
> 3、不同的C编译器在实现char是有符号还是无符号类型还有所不同。有符号位意味着char可表示的范围是-128~127；无符号位意味着char可表示的范围是0~255。
>
> 4、基于C编译器实现char是有符号还是无符号类型还有所不同，那么在用char处理小整数时，可以采用`unsigned char`直接表示char型变量是无符号的。

基于char 处理小整数的范围，代码演示一下：

```
#include <stdio.h>

/**
 * @return
 */
int main() {

    char a = 129;
    printf("a = %c, a = %d \n", a, a);
    unsigned char b = 129;
    printf("b = %c, b = %d", b, b);
}
```

输出结果

```
a = �, a = -127 
b = �, b = 129
```

### 7.2 char型数据的初始化

因为char类型底层使用整数存储的原因，所以在初始化char型数据时，有如下的几种方式。

- 直接使用单引号（'）初始化字符。
- 使用字符对应的ASCII中的整数初始化赋值（不推荐）。

代码演示

```c
#include <stdio.h>

/**
 * char 数据类型的初始化
 * @return
 */
int main() {

    char a = 'A';
    char b = 65;
    char c = 0101;
    // 当给单个char型变量初始化多个字符时，只会取最后一位有效的字符
    char d = 'FATE';
    // 这里是用16位存储的，那么就直接会截取后面8位表示，0x31 => 49(整数) => 1（字符）
    char e = 0x1131;

    printf("a = %c, b = %c, c = %c \n", a, b, c);
    // 当我们以整数的形似输出时，会把char型数据转化成整型输出
    printf("d = %d, d = %c \n", d, d);
    printf("e = %d, e = %c", e, e);

}
```

输出结果

```
a = A, b = A, c = A 
d = 69, d = E 
e = 49, e = 1
```

> 注意：
>
> 1、当使用整数初始化字符时，当整数的值超过了char类型数据的取值范围（8位），那么还是只会截取有效的八位进行表示。
>
> 2、可以使用八进制或者十六进制表示转化成十进制数后对应的字符。

### 7.3 打印特殊字符

单引号只适用于字符、数字和标点符号，对于ASCII码表中，有些特殊的字符是打印不出来的。比如，退格、换行、终端响铃、蜂鸣等。C语言中提供了三种方式表示这些字符。

- 使用字符在ASCII码中对应的整数。
- 使用转义字符（\）表示，也叫做转义序列。

#### 7.3.1 特殊字符使用转义字符表示的方式

| 转义序列 | 特殊字符                                                     |
| -------- | ------------------------------------------------------------ |
| \a       | 警报（ANSI C）                                               |
| \b       | 退格                                                         |
| \f       | 换页                                                         |
| \n       | 换行（表示把光表移动到下一行的开始处）                       |
| \r       | 回车（表示把光标移动到当前行的开始处）                       |
| \t       | 水平制表符                                                   |
| \v       | 垂直制表符                                                   |
| \\       | 反斜杠（\）                                                  |
| \'       | 单引号                                                       |
| \"       | 双引号                                                       |
| \?       | 问号                                                         |
| \0oo     | 八进制值（oo必须是有效的八进制数，会将八进制数转化成十进制数对应的字符） |
| \xhh     | 十六进制值（hh必须是有效的十六进制数，会将十六进制数转化成十进制数对应的字符） |

> 注意：
>
> 1、当使用转义字符结合八进制表示字符，八进制有效数字只有两位, 当超过两位时，会将有效的两位数转成十进制再转成对应的字符，超出的部分全部都当做字符处理，那么就相当于为char型变量赋予多个字符，有效的自然就是最后一位字符。
>
> 2、特别的，在C语言中当用反斜杠+八进制表示字符时，八进制的特殊符号0是可以省略的。此时反斜杠后面的三位就是有效数字，如果三位数字表示的范围过大的话，会编译失败，抛出`Octal escape sequence out of range`错误。
>
> 3、十六进制的反斜杠不能省略，后面可尾随1~3位有效数字。当三位有效数字表示的数字过大时，会编译失败，超出范围，抛出`ex escape sequence out of range`错误。
>
> 4、当转义字符后面的字符没有实际意义时，转义字符会被忽略。
>
> 5、在打印字符时，对于双引号里面的八进制，如果后面的数字都满足条件，会按照最大限度解析，即解析三位数。

代码演示

```c
#include <stdio.h>

/**
 * char 打印特殊字符
 * @return
 */
int main() {

    char a = '\\';
    // 打印反斜杠对应的整数和字符
    printf("a = %d, a = %c \n", a, a);

    // 当使用转义字符结合八进制表示字符
    char b = '\061';
    printf("b = %d, b = %c \n", b, b);

    // 八进制有效数字只有两位, 当超过两位时，
    // 会将有效的两位数转成十进制再转成对应的字符，
    // 超出的部分全部都当做字符处理
    // 那么就相当于位char型变量赋予多个字符，有效的自然就是最后一位字符
    // 此时的c相当于初始化整数8对应的字符 + 字符 '1'， 最后c有效的值为字符1
    char c = '\0101';
    printf("c = %d, c = %c \n", c, c);

    // 特别的，在C语言中当用反斜杠+八进制表示字符时，八进制的特殊符号0是可以省略的
    // 此时反斜杠后面的三位就是有效数字,
    // 如果三位数字表示的范围过大的话，会编译失败
    // 抛出Octal escape sequence out of range
    // 此时的d就代表65对应的字符 'A'
    char d = '\101';
    printf("d = %d, d = %c \n", d, d);

    // 十六进制的反斜杠不能省略，后面可尾随1~3位有效数字
    char e = '\x030';
    printf("e = %d, e = %c \n", e, e);

    // 当三位有效数字表示的数字过大时，汇编失败，超出范围
    // hex escape sequence out of range
    // char f = '\xAAA';

    // 在打印字符时，对于双引号里面的八进制，如果后面的数字都满足条件会解析三位数
    printf("八进制101对应的字符 => \10101010");

}
```

输出结果

```
a = 92, a = \ 
b = 49, b = 1 
c = 49, c = 1 
d = 65, d = A 
e = 48, e = 0 
八进制101对应的字符 => A01010
```

## 8. 基本数据类型之_Bool类型

Bool类型用于表示布尔值，即逻辑值true个false。

> 注意：
>
> 1、在C语言中1表示true，0表示false，所以布尔类型实际上也是一种整数类型。
>
> 2、原则上布尔值仅占用1位存储空间。
>
> 3、当将其他类型的值初始化给布尔类型的值时，非0的值会被转化成1赋值给变量。

代码演示

```c
#include <stdio.h>

/**
 * _Bool类型
 * @return
 */
int main() {

    _Bool a = 2;
    printf("a = %d", a);
}
```

输出结果

```
a = 1
```

## 9. 可移植类型

> 可移植类型表示可确保C语言的类型在各系统中的功能相同。

由于C语言的某些数据类型在不同的系统中的功能不一样，所以C99中新增了两个头文件

- stdint.h
- inttypes.h

通过这两个头文件中引入的部分数据类型，可以确保该数据类型在各系统中的功能相同。

### 9.1stdint.h

stdint.h头文件主要就是声明各种类型的数据类型，以达到数据类型可移植的目的。

声明的数据类型达到可移植的功能实现方式有如下几种：

| 实现方式         | 描述                                                         | 数据类型示例                                                 |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 精确宽度整数类型 | 通过区分不同的系统，根据指定的精确宽度生成不同的数据类型。   | int32_t：表示无论在什么系统下，生成固定32位的数据类型。比如，在32位int系统中，头文件会把int32_t作为int的别名；在int位16位、long为32位的系统中，头文件会把int32_t作为long的别名。 |
| 最小宽度类型     | 类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。   | int_lease8_t：是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。 |
| 最快最小宽度类型 | 类型名保证所表示的类型对指定的类型运算速度最快的类型。       | int_fast8_t：定义为系统中对8位有符号值而言运算最快的整数类型的别名。 |
| 最大整数类型     | 类型名保证所表示的类型是当前系统能存储对应数据类型最大的数据类型。 | intmax_t：可存储最大的有符号的整数类型。<br/>unintmax_t：可存储最大的无符号的整数值类型。 |

### 9.2 inttypes.h

inttypes.h头文件主要是针对不同系统可移植的输入和输出。比如，printf打印特定类型时要求与相应的转换说明匹配。

inttypes.h头文件实现该功能主要是通过提供了一些 `字符串宏`。比如，`PRId32字符串宏`代表不论是在什么系统下，打印32位有符号值。

- 代码演示

```c
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

/**
 * 可移植类型
 * @return
 */
int main() {
    // 精确宽度整数类型，无论在什么系统下，都会固定转换为32位的数据类型
    int32_t a = 32;
    printf("a = %d \n", a);
    // 在32位系统中，PRId32 相当于 \d
    // 此时就类似于 "a = %" "d" " \n"
    // 在C语言中，可以把多个连续的字符串组合成一个字符串
    // 最后相当于 "a = %d \n"
    printf("a = %" PRId32 " \n", a);
    return 0;
}
```

- 输出结果

```
a = 32 
a = 32 

```

## 10. 基本数据类型之浮点型

### 10.1 浮点型数据类型的取值范围

| 数据类型    | 有效数字                                                     | 内存占用                                                     | 取值范围                    |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------------------- |
| float       | 必须至少能表示6位有效数字。（float类型必须至少精确表示小数点后的6位有效数字） | 通常，要占用32位字节，其中8位用于表示指数的值和符号，剩下的24位用于表示非指数部分及其符号。 | 取值范围至少是10^-37~10^+37 |
| double      | 必须至少能表示10位有效数字                                   | 通常，要占用64位字节，其中8位用于表示指数的值和符号，剩下的56位用于表示非指数部分及其符号。增加有效数字的位数，提高精度，减少舍入误差。（注：有些系统会将多出32位的一部分分配给指数，以容纳更大的指数，增加可表示数的范围） | 取值范围至少是10^-37~10^+37 |
| long double |  |C只保证long double类型的至少与double类型的精度相同，但实际上long double 用于比double类型更高精度的场景。||

> 注意：
>
> 1、默认情况下，编译器假定浮点型常量是double类型的精度。可通过对浮点数常量后面加上f或者F后缀来表示float类型；使用l或者L后缀来表示long double类型。
>
> 2、float有6位有效数字表示至少精确到小数点后6位有效数字，也就是说，在实际的执行过程中，float的小数点后6位是精确地，其他的小数可能会损失精度。
>
> 3、当将double强转成float时，十位有效数字会变成6位， 那么会导致精度丢失。

### 10.2 打印浮点数

针对浮点数常量不同的表示方式，可分为三种打印方式

| 浮点数常量类型   | 占位符             |
| ---------------- | ------------------ |
| 十进制普通浮点数 | %f                 |
| e计数法          | %e                 |
| 十六进制浮点数   | %a和%A分别代替p和P |

> 注意：
>
> 1、如果是long doule类型，上述的占位符前面都需要添加L。
>
> 2、对于特殊的浮点值NaN（not a number），打印时返回nan、NaN。

代码演示

```c
#include <stdio.h>

/**
 * 打印浮点数
 * @return
 */
int main() {

    float a = 314.F;
    double b = 3.14e2;
    long double c = 0xa.1fp10;

    printf("a = %f, a = %e, a = %a \n", a, a, a);
    printf("b = %f, b = %e, b= %a \n", b, b, b);
    // long double 类型打印时需要添加上L
    printf("c = %Lf, c = %Le, c = %La \n", c, c, c);
}
```

输出结果

```
a = 314.000000, a = 3.140000e+02, a = 0x1.3ap+8 
b = 314.000000, b = 3.140000e+02, b= 0x1.3ap+8 
c = 10364.000000, c = 1.036400e+04, c = 0xa.1fp+10 
```

### 10.3 浮点数的上溢和下溢

浮点数上溢表示数字超出了当前类型能表达的范围，这种情况下，会返回一个表示无穷大的特定值，打印该值就是inf或者是infinity。

浮点数下溢表示当指数已经是最小值，该值被除以某个值后要减少指数，但是指数无法在小时，会直接改变小数部分往后移动，那么原先的小数的最后一位就会被舍弃，这种情况就是下溢。简单来说，就是用尾数丢弃的方式替换指数的减少时，就会发生下溢。发生下溢的浮点数被称为低于正常的浮点值。

举例来说，3.14159e-10假定指数部分最小都是-10了，当我们将该值除以10时，由于指数部分不能变小现在就会变成0.314159e-10，但是当小数部分也不能表示这么多数时，就会抛弃小数最后一位9也就是结果为0.31415e-10，这样就是下溢。

### 10.4 浮点数舍入错误

计算机缺少足够的小数位来完成正确的运算时就会发生舍入错误，也就是精度损失。浮点数的下溢也就是一个舍入错误的例子。

- 代码演示

```c
#include <stdio.h>

/**
 * 浮点数舍入错误
 * @return
 */
int main() {

    // 因为较大的数涉及到计算时，计算机可表示的小数部分超过了阈值
    // 就会出现舍入错误
    float a = 2e20F + 1.0F - 1.0F;
    printf("%f", a);

}
```

- 输出结果

```
200000004008175468544.000000
```

## 11. 数据类型之虚数与复数

> 什么是虚数、复数？
>
> 我们把形如 `z = a + bi`（a，b均为实数）的数成为复数。
>
> 其中a称为实部，b称为虚部，i称为虚数单位。 
>
> 当z的虚部等于0时，常称为z为`实数`；当z的虚部不等于0，实部等于0时，常称为`纯虚数`。
>
> 我们把形如 `z = a + bi 且 b!=0,i^2=-1`的数成为虚数。

### 11.1 复数类型

| 复数类型             | 描述                                                         |
| -------------------- | ------------------------------------------------------------ |
| float _Complex       | float_Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。 |
| double _Complex      |                                                              |
| long double _Complex |                                                              |

### 11.2 虚数类型

| 虚数类型                | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| float _Imaginary        | float _Imaginary类型的变量应包含两个float类型的值，分别表示虚数的实部和虚部。 |
| double _Imaginary       |                                                              |
| long double  _Imaginary |                                                              |

> 注意：
>
> 1、如果包含complex.h头文件，便可用complex代替\_Complex关键字，用imaginary代替\_Imaginary，还可用I代替-1的平方根。

## 12. 获取数据类型的大小

可通过 `sizeof` 内置运算符，以字节为单位给出指定类型的大小。一般可以用int、unsigned int等整数数据类型接收。

格式化打印sizeof的值，官方推荐用 `%zd`，实际上还可以用对应的整数占位符来表示。

- 代码演示

```c
#include <stdio.h>

/**
 * 获取数据类型的大小
 * @return
 */
int main() {

    int a = sizeof(double);
    printf("%d \n", a);

    printf("%lu, %u, %zd", sizeof(int), sizeof(char ), sizeof(float));

}
```

- 输出结果

```
8 
4, 1, 4
```

## 13. 刷新输出

一把情况下，printf函数会把输出发送到一个叫做 `缓冲区（buffer）`的中间存储区域，然后缓冲区中的内容再不断的被发送到屏幕上。

何时会将缓冲区中的内容发送到屏幕呢？有如下几种场景：

- 当缓冲区满
- 当遇到换行字符（\n）
- 遇到用户输入的时候
- 调用fflush函数（force flush强制刷新）

这种将缓冲区的数据发送到屏幕或者文件的操作被称为 `刷新缓冲区`。